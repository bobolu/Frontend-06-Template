# 学习笔记
## HTML解析 | HTML parse模块的文件拆分

### 第一步总结
- 为了方便文件管理，把 parser 单独才分到文件中
- parser 接受 HTML 文本作为参数，返回一颗 DOM 树 

### 第二步总结
- 使用 FSM （有限状态机简写）实现 HTML 分析
- 在 HTML 标签中，已经规定了 HTML 的状态

### 第三步 解析标签
- 主要的标签有：开始标签，结束标签和自闭合标签

### 第四步 创建元素
- 在状态机中，除了状态迁移，还需要加入业务逻辑
- 在标签结束状态提交标签 token

### 第五步 处理属性
- 属性值分为单引号、双引号、无引号三种写法，因此需要较多的状态处理
- 处理属性的方式和标签类似
- 属性结束时，把属性加到标签token上

### 第六步 构建DOM树
- 从标签构建 DOM 树的基本技巧是使用栈
- 遇到开始标签时创建元素并入栈，遇到结束标签的时候出栈
- 自闭合标签可以视为入栈后立刻出栈
- 任何元素的父元素是它入栈前的栈定

### 第七步 处理文本节点
- 文本节点与自闭合标签处理类似
- 多个文本节点需要合并

至此，完成了 HTML 的解析。

## CSS计算

### 第一步 收集CSS规则

- 遇到 style 标签时，把 CSS 规则保存起来
- 调用 CSS Parser 来分析CSS规则
- 仔细研究CSS库分析CSS规则的格式

### 第二步 添加调用

- 创建一个元素后，立即计算 CSS
- 理论上，分析一个元素时，所有CSS规则已经收集完毕
- 在真实浏览器中，可能遇到写在 body 的 style 标签内，需要重新 CSS 计算的情况，此处我们忽略

### 第三步 获取父元素序列

- 在 computeCss 函数中，必须知道元素的所有父元素才能判断元素与规则是否匹配
- 从上一步骤的 stack，可获取本元素所有的父元素
- 因为首先获取的是“当前元素”，所以我们获得和计算父元素匹配的顺序是内向外

### 第四步 拆分选择器

- 先择器也要从当前元素向外排列
- 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

### 第五步 获取父元素序列

- 根据选择器的类型和元素属性，计算是否与当前元素匹配
- 这里仅实现了三种基本选择器，实际的浏览器中要处理复合选择器

### 第六步 获取父元素序列

- 一旦选择匹配，就应用选择器到元素上，形成 computedStyle

### 第七步 获取父元素序列

- CSS 规则根据 specificity 和后来优先规则覆盖
- specificity 是个四元组，越左边权重越高
- 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成

本周的学习，基本一步一步跟着思路走，对于 HTML 解析和 CSS 计算过程有了基本的认识。具体的复杂和完善的实现还需要更多的消化和学习。

